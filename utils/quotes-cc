#!/usr/bin/env perl
use Modern::Perl;
use YAML::XS qw(LoadFile);
use Template;

=head1 NAME

quotes-cc - Compile failo's YAML quotes file to a fast C program that prints one of them randomly to STDOUT when invoked

=head1 SYNOPSIS

    perl -COEL ~avar/g/failo/utils/quotes-cc ~failo/failo/quotes.yml | gcc -x c -o /usr/local/bin/failo-wisdom -
    failo-wisdom

=head1 AUTHOR

E<AElig>var ArnfjE<ouml>rE<eth> Bjarmason <avar@cpan.org>

=cut

die "Specify a YAML file as an argument" unless $ARGV[0] and -f $ARGV[0];

my @quotes = @{ LoadFile( $ARGV[0] ) };
my $size = @quotes;

binmode STDOUT, ":utf8";
Template->new->process(\*DATA, {
    quotes => \@quotes,
    size => $size,
    escape => sub {
        my $_ = shift;
        s/"/\\"/g;
        qq["$_"];
    },
});

__DATA__
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/time.h>

const char* const quotes[[% size %]] = {
[% FOREACH quote IN quotes
%]    [% escape(quote) %],
[% END
%]};

/* returns random integer between min and max, inclusive */
const int rand_range(const int min, const int max)
{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    const long int n = tv.tv_usec * getpid();
    srand(n);

    return (rand() % (max + 1 - min) + min);
}

const int main(const int argc, const char **argv)
{
    int i;
    const char* const all = "--all";
    const size_t all_length = strlen(all);

    if (argc == 2 &&
        strlen(argv[1]) == all_length &&
        !strncmp(argv[1], all, all_length)) {
        for (i = 0; i < [% size %]; i++) {
            puts(quotes[i]);
        }
    } else {
        const int quote = rand_range(0, [% size %]);
        puts(quotes[quote]);
    }

    return EXIT_SUCCESS;
}
